<p>Have you ever wondered why you can't list-initialize vectors of non-copyable types? This is for instance not possible:</p>

<!-- snippetysnip:main.cpp:vector_unique:(before='[sourcecode language="cpp"]', after='[/sourcecode]') -->

<p>[sourcecode language="cpp"]
    vector<unique_ptr<int>> vu{make<em>unique<int>(1), make</em>unique<int>(2)};
    //error: call to implicitly-deleted copy constructor of unique_ptr
[/sourcecode]</p>

<!-- snippetysnip_end:main.cpp:vector_unique -->

<p>If you ever wondered, or if you now are, read on!</p>

<p>Since C++11, you're probably used to intitalizing vectors like this:</p>

<!-- snippetysnip:main.cpp:vector_int:(before='[sourcecode language="cpp"]', after='[/sourcecode]') -->

<p>[sourcecode language="cpp"]
    vector<int> vi1{1,2,3};
    vector<int> vi2 = {1,2,3};
[/sourcecode]</p>

<!-- snippetysnip_end:main.cpp:vector_int -->

<p>This of course also works with user defined types. Let's say you have a class <code>Copyable</code>, then you can for instance do:</p>

<!-- snippetysnip:main.cpp:vector_copyable:(before='[sourcecode language="cpp"]', after='[/sourcecode]') -->

<p>[sourcecode language="cpp"]
    Copyable c1(1);
    Copyable c2(2);
    vector<Copyable> vc1{c1, c2};
    vector<Copyable> vc2 = {c1, c2};
[/sourcecode]</p>

<!-- snippetysnip_end:main.cpp:vector_copyable -->

<p>The <code>Copyable</code> class is reproduced at the end of the post, but in short it has a constructor taking an <code>int</code>, and a <code>default</code>ed copy constructor, move constructor, copy assignment operator and move assignment operator.</p>

<p>Now what happens if we have a non-copyable class <code>NonCopyable</code>? It can also be seen at the end of the post, but is identical to <code>Copyable</code> except that the move constructor and move assignment operators have been <code>delete</code>ed.</p>

<!-- snippetysnip:main.cpp:vector_noncopyable:(before='[sourcecode language="cpp"]', after='[/sourcecode]') -->

<p>[sourcecode language="cpp"]
    NonCopyable n1(1);
    NonCopyable n2(2);
    vector<NonCopyable> vn1{n1, n2}; //error: call to deleted constructor of 'const NonCopyable'
    vector<NonCopyable> vn2 = {n1, n2}; //error: call to deleted constructor of 'const NonCopyable'
[/sourcecode]</p>

<!-- snippetysnip_end:main.cpp:vector_noncopyable -->

<p>Well, <code>n1</code> and <code>n2</code> are lvalues, so no wonder it tries to copy them. What if we turn them into <code>rvalues</code>, either with <code>std::move</code> or by creating temporaries?
<!-- snippetysnip:main.cpp:vector_noncopyable_move:(before='[sourcecode language="cpp"]', after='[/sourcecode]') --></p>

<p>[sourcecode language="cpp"]
    vector<NonCopyable> vn3{move(n1), move(n2)}; //error: call to deleted constructor of 'const NonCopyable'
    vector<NonCopyable> vn3{NonCopyable(4), NonCopyable(5)}; //error: call to deleted constructor of 'const NonCopyable'
[/sourcecode]</p>

<!-- snippetysnip_end:main.cpp:vector_noncopyable_move -->

<p>So what's going on here? Let's see what the standard has to say in [dcl.init.list]Â¶1:</p>

<blockquote>
  <p><em>List-initialization</em> is initialization of an object or reference from a <em>braced-init-list</em>.</p>
</blockquote>

<p>A <em>braced-init-list</em> is the <code>{elements, go, here}</code> syntax we saw above. The standard continues:</p>

<blockquote>
  <p>Such an initializer is called an initializer list. (...) List-initialization can occur in direct-initialization or copy-initialization contexts.</p>
</blockquote>

<h4>Appendix: The <code>Copyable</code> and <code>Uncopyable</code> classes:</h4>

<p><!-- snippetysnip:main.cpp:classes:(before='[sourcecode language="cpp"]', after='[/sourcecode]') --,</p>

<p>[sourcecode language="cpp"]
class Copyable {
public:
    Copyable(int i): i(i){}
    Copyable(const Copyable&amp;) = default;
    Copyable(Copyable&amp;&amp;) = default;
    Copyable&amp; operator=(const Copyable&amp;) = default;
    Copyable&amp; operator=(Copyable&amp;&amp;) = default;
    ~Copyable() = default;
    int i;
};</p>

<p>class NonCopyable {
public:
    NonCopyable(int i): i(i){}
    NonCopyable(const NonCopyable&amp;) = delete;
    NonCopyable(NonCopyable&amp;&amp;) = delete;
    NonCopyable&amp; operator=(const NonCopyable&amp;) = default;
    NonCopyable&amp; operator=(NonCopyable&amp;&amp;) = default;
    ~NonCopyable() = default;
    int i;
};
[/sourcecode]</p>

<p><!-- snippetysnip_end:main.cpp:classes --,</p>

<hr>

<p>{} is braced initialization. in this case it means list-initialization.</p>

<p>Copying an initializer-list does not copy the underlying elements, and the only way to iterate over it is by const pointers:
[support.initlist] only has
constexpr const E* begin() const noexcept; // first element
constexpr const E* end() const noexcept; // one past the last element</p>

<p>So there's no way to copy out of it.</p>

<p>Say something about this not being related to whether we direct initialize or copy initialize, the latter actually supports moving non-copyable types</p>
